# -*- coding: utf-8 -*-
"""DRONE-client.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XOqDF04_gOYYvlMdfX1NF_1APDq5CdhX
"""

import socket
import time
import cv2
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
from threading import Thread
#from picamera import PiCamera

class AirDRONE:
  def __init__(self):
    self.proximeter       = Proximeter()
    self.netSender        = Client()
    self.saving_directory = '/home/pi/Desktop/'
    self.timetable_dict   = {}                  #sent time: | sugested wait time: | real wait time :

  def capture_photo(self, filename):
    camera        = PiCamera()
    saved_dir     =   self.saving_directory + filename + '.jpg'
    time.sleep(5)
    camera.capture(saved_dir)
    camera.close()
    return saved_dir

  def record_sentTime(self,filename):
      current        = self.proximeter.get_time()
      sugessted_time = self.proximeter.suggest_waitingTime()
      real_time      = None
      
      self.timetable_dict[filename] = [current, sugessted_time, real_time]

  def record_reciveTime(self, filename):
    real_time                        = self.proximeter.get_time()
    self.timetable_dict[filename][2] = real_time

  
  
  def add_INDXbytes(self, byte_data, num):
    byte_data   = bytearray(byte_data)
    byte_to_add = num.to_bytes(2, byteorder='big')
    byte_data.extend(byte_to_add)
    return bytes(byte_data)
  
  def process_image(self, img_dir):
      myfile = open(img_dir, 'rb')
      bytes = myfile.read()
      return bytes

  def send_image(self, indx, img_dir): # 0 =< indx <= 9
      image_bytes = self.process_image(img_dir)
      final_bytes = self.add_INDXbytes(image_bytes, indx)
      self.netSender.send(final_bytes)
      self.proximeter.record_sendTime(img_dir)
      self.record_sentTime(img_dir)

  def runDrone(self):
    img_counter = 0
    while True:
      
      self.send_image(img_counter%10, self.capture_photo(str(img_counter)))
      sugested_wait  = self.proximeter.suggest_waitingTime()
      Thread(target = self.netSender.recive_location).start()

  def recive(self):
    loc = self.netSender.recive_location()

class Proximeter:
  def __init__(self):
    self.timeTable_dict = {}
    self.elapsedTime    = []
  
  def get_time():
    return datetime.utcnow().strftime('%H:%M:%S.%f')

  
  def time_diff(self, time1, time2):
    """
    time1, time2: str; time1 and time2 in the format of hh:mm:ss
    return: int; time difference of time1 and time2 in seconds
    """
    time1 = time1.split(':')
    time2 = time2.split(':')
    time1 = [int(i) for i in time1]
    time2 = [int(i) for i in time2]
    time1 = time1[0]*3600 + time1[1]*60 + time1[2]
    time2 = time2[0]*3600 + time2[1]*60 + time2[2]
    return abs(time1 - time2)

  def record_reciveTime(self, filename):
    current_time   = self.get_time()
    submited_time  = self.timeTable_dict[filename]
    diffrence_time = self.time_diff(current_time, submited_time)
    self.elapsedTime.append(diffrence_time)

  def record_sendTime(self, filename):
    self.timeTable_dict[filename] = self.get_time()

  def moving_avg(x, N=3):
    cumsum = np.cumsum(np.insert(x, 0, 0))
    return (cumsum[N:] - cumsum[:-N]) / float(N)

  def exp_moving_avg(self, list, alpha=0.125):
    """
    Calculate exponentially weighted moving average of a list
    """
    ema = []
    for i in range(len(list)):
        if i == 0:
            ema.append(list[i])
        else:
            ema.append(alpha * list[i] + (1 - alpha) * ema[i - 1])
    return ema

  def plot_EMA(self):
    plt.plot(self.exp_moving_avg(self.elapsedTime))
    plt.show()

  def suggest_waitingTime(self):
     EMA_list = self.exp_moving_avg(self.elapsedTime)
     return EMA_list[-1]

class Client:
    def __init__(self, ip, in_port, out_port):
      self.ip = ip
      self.out_port = out_port
      self.in_port  = in_port
      self.out_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      self.in_sock  = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      self.in_sock.bind(('', self.in_port))

    
    def send(self, data):
      self.out_sock.sendto(data, (self.ip, self.out_port))

    def recive_location(self):
      loc, addr = self.in_sock.recvfrom(5555)
      return loc

if __name__ == '__main__':
    client = Client('5.237.183.66', 5005)
    img = np.random.rand(480,640, 3)
    while True:
      client.send(img)